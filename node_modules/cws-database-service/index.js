'use strict';

var logger = require('cws-logger');
var config = require('cws-config');

var filename = 'DatabaseService';

// async
exports.save = function(document) {
	return new Promise(function(resolve, reject) {
		if (!document) {
			logger.error(filename, 'save:' + 'document is null');
			reject(new Error('document is null'));
		}

		document.save(function(err) {
			if (err) {
				logger.error(filename, 'save:' + err);
				reject(new Error(err));
			} else {
				logger.info(filename, 'save:' + 'inserted successfully');
				resolve('inserted successfully');
			}
		});
	});

	return promise;
};

exports.search = function(model, queryString) {
	var promise = new Promise(function(resolve, reject) {
 		if (!model) {
 			logger.error(filename, 'search:' + 'model is null');
 			reject(new Error('model is null'));
 		}

 		if (!queryString) {
 			logger.error(filename, 'search:' + 'queryString is null');
 			reject(new Error('queryString is null'));
 		}

 		model.search({ query:queryString }, function(err,results) {
 			if (err) {
 				reject(new Error(err));
 			} else {
 				resolve(results);
 			}
 		});
 	});

 	return promise;
}

exports.findContents = function(model, endDate, startDate) {
	var promise = new Promise(function(resolve, reject) {
		if (!model) {
			logger.error(filename, 'findContents:model is null');
			reject(new Error('model is null'));
		}

		if (!startDate && !endDate) {
			model.find().limit(config.limit*2).sort({ createdAt: -1 })
				.exec(function(err, documents) {
					if (err) {
						logger.error(filename, err);
						reject(new Error(err));
					} else {
						resolve(documents);
					}
				});
		} else if (!startDate) {
			model.find({ 'createdAt': { $lte: endDate }})
	 			.limit(config.limit).sort({ createdAt: -1 })
	 			.exec(function(err, documents) {
	 				if (err) {
						logger.error(filename, err);
						reject(new Error(err));
					} else {
						resolve(documents);
					}
	 			});
		} else if (startDate && endDate) {
			model.find({ 'createdAt': { $gt: startDate, $lte: endDate }})
	 			.limit(config.limit).sort({ createdAt: -1 })
	 			.exec(function(err, documents) {
	 				if (err) {
						logger.error(filename, err);
						reject(new Error(err));
					} else {
						resolve(documents);
					}
	 			});
		} 
	});

	return promise;
}

exports.find = function(model) {
 	var promise = new Promise(function(resolve, reject) {
 		if (!model) {
 			logger.error(filename, 'find:' + 'model is null');
 			reject(new Error('model is null'));
 		}

		model.find().sort({ createdAt: -1 }).limit(config.limit*2)
			.exec(function(err, documents) {
				if (err) {
					logger.error(filename, err);
					reject(new Error(err));
				} else {
					//logger.info(filename, documents);
					resolve(documents);
				}
			});
	});

	return promise;
};

exports.findLastCreated = function(model, lastCreatedDate) {
	var promise = new Promise(function(resolve, reject) {
		if (!model) {
 			logger.error(filename, 'findLastCreated:' + 'model is null');
 			reject(new Error('model is null'));
 		}

 		if (!lastCreatedDate) {
 			logger.error(filename, 'findLastCreated:' + 'lastCreatedDate is null');
 			reject(new Error('lastCreatedDate is null'));
 		}

 		model.find({ 'createdAt': { $lt: lastCreatedDate }})
 			.sort({ createdAt: -1 }).limit(config.limit)
 			.exec(function(err, documents) {
 				if (err) {
					logger.error(filename, err);
					reject(new Error(err));
				} else {
					resolve(documents);
				}
 			});
	});

	return promise;
}

// async
exports.findOne = function(model, options) {
	var promise = new Promise(function(resolve, reject) {
		if (!model) {
			logger.error(filename, 'findOne:' + 'model is null');
			reject(new Error('model is null'));
		}

		if (!options) {
			reject(new Error('options is null'));
		}

		model.findOne(options, function(err, result) {
			if (err) {
				logger.error(filename, err);
				reject(new Error(err));
			} else if (!result) {
				logger.error(filename, 'no results found');
				reject(new Error('no results found'));
			} else {
				logger.info(filename, result);
				resolve(result);
			}
		});	
	});

	return promise;
};

// async
exports.findOneAndUpdate = function(model, conditions, update) {
	var promise = new Promise(function(resolve, reject) {
		if (!model) {
			logger.error(filename, 'findOneAndUpdate:' + 'model is null');
			reject('model is null');
		}

		if (!conditions) {
			logger.error(filename, 'findOneAndUpdate' + 'conditions is null');
			reject('conditions is null');
		}

		if (!update) {
			logger.error(filename, 'findOneAndUpdate' + 'update is null');
			reject('update is null');
		}

		model.findOneAndUpdate(conditions, update, function(err, result) {
			if (err) {
				logger.error(filename, 'findOneAndUpdate:' + err);
				reject(new Error(err));
			} else {
				logger.info(filename, 'findOneAndUpdate:' + 'udpated successfully');
				resolve('updated successfully');
			}
		});
	});

	return promise;
};